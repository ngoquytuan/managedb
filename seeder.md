T√¥i s·∫Ω t·∫°o script Python ƒë·ªÉ nh·∫≠p d·ªØ li·ªáu gi·∫£ v√†o database v√† FAISS collections ƒë·ªÉ test h·ªá th·ªëng. Script n√†y s·∫Ω t·∫°o conversations, documents v√† analytics data realistic.

## data_seeder.py

```python
#!/usr/bin/env python3
"""
Data Seeder for Enterprise Chatbot
T·∫°o d·ªØ li·ªáu gi·∫£ ƒë·ªÉ test database v√† FAISS collections
"""

import asyncio
import os
import sys
import json
import random
import time
from datetime import datetime, timedelta
from typing import List, Dict, Any
from dataclasses import dataclass
import uuid

import psycopg2
from psycopg2.extras import RealDictCursor
import redis
from dotenv import load_dotenv

# Add project root to path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from engines.faiss_manager import FAISSCollectionManager, DocumentChunk
from models.schemas import PageContext

# Load environment variables
load_dotenv()

@dataclass
class FakeConversation:
    session_id: str
    user_message: str
    bot_response: str
    intent: str
    target_product: str
    confidence: float
    processing_time: float
    user_ip: str
    created_at: datetime

class DataSeeder:
    def __init__(self):
        self.db_url = os.getenv('DATABASE_URL')
        self.redis_host = os.getenv('REDIS_HOST', 'localhost')
        self.redis_port = int(os.getenv('REDIS_PORT', 6379))
        
        if not self.db_url:
            raise ValueError("DATABASE_URL not found in environment variables")
        
        # Initialize connections
        self.redis_client = redis.Redis(
            host=self.redis_host,
            port=self.redis_port,
            decode_responses=True
        )
        
        self.faiss_manager = FAISSCollectionManager()
        
        print(f"‚úì Database: {self.db_url}")
        print(f"‚úì Redis: {self.redis_host}:{self.redis_port}")
    
    async def seed_all_data(self):
        """Seed t·∫•t c·∫£ d·ªØ li·ªáu test"""
        print("\nüöÄ B·∫Øt ƒë·∫ßu seeding d·ªØ li·ªáu test...")
        
        try:
            # 1. Seed FAISS collections v·ªõi documents
            await self.seed_faiss_documents()
            
            # 2. Seed database v·ªõi conversations
            await self.seed_conversations()
            
            # 3. Seed Redis v·ªõi cache data
            await self.seed_cache_data()
            
            # 4. Verify data
            await self.verify_data()
            
            print("\n‚úÖ Ho√†n th√†nh seeding d·ªØ li·ªáu!")
            
        except Exception as e:
            print(f"\n‚ùå L·ªói khi seeding: {e}")
            raise
    
    async def seed_faiss_documents(self):
        """Seed FAISS collections v·ªõi sample documents"""
        print("\nüìö Seeding FAISS documents...")
        
        # Initialize FAISS collections
        await self.faiss_manager.initialize_collections()
        
        # Sample documents cho t·ª´ng collection
        documents_data = {
            'product_a_features': self.get_product_a_features_docs(),
            'product_a_pricing': self.get_product_a_pricing_docs(),
            'product_b_features': self.get_product_b_features_docs(),
            'warranty_support': self.get_warranty_support_docs(),
            'contact_company': self.get_contact_company_docs()
        }
        
        total_docs = 0
        for collection_name, docs in documents_data.items():
            print(f"  ‚Ä¢ Adding {len(docs)} documents to {collection_name}...")
            
            # Convert to DocumentChunk objects
            document_chunks = []
            for i, doc in enumerate(docs):
                chunk = DocumentChunk(
                    content=doc['content'],
                    metadata={
                        'title': doc.get('title', f'Document {i+1}'),
                        'category': doc.get('category', 'general'),
                        'product': doc.get('product'),
                        'section': doc.get('section'),
                        'source': doc.get('source', 'manual'),
                        'doc_id': f"{collection_name}_{i+1}"
                    }
                )
                document_chunks.append(chunk)
            
            # Add to FAISS collection
            added_count = await self.faiss_manager.add_documents_to_collection(
                collection_name, document_chunks
            )
            total_docs += added_count
            print(f"    ‚úì Added {added_count} documents")
        
        print(f"üìö Total documents added: {total_docs}")
    
    async def seed_conversations(self):
        """Seed database v·ªõi sample conversations"""
        print("\nüí¨ Seeding conversations...")
        
        conversations = self.generate_fake_conversations(500)  # 500 conversations
        
        conn = psycopg2.connect(self.db_url)
        cursor = conn.cursor()
        
        try:
            # Insert conversations
            insert_query = """
            INSERT INTO conversations 
            (session_id, user_message, bot_response, intent, target_product, 
             confidence, processing_time, sources_count, user_ip, created_at)
            VALUES (%(session_id)s, %(user_message)s, %(bot_response)s, %(intent)s, 
                    %(target_product)s, %(confidence)s, %(processing_time)s, 
                    %(sources_count)s, %(user_ip)s, %(created_at)s)
            """
            
            batch_size = 50
            for i in range(0, len(conversations), batch_size):
                batch = conversations[i:i + batch_size]
                batch_data = []
                
                for conv in batch:
                    batch_data.append({
                        'session_id': conv.session_id,
                        'user_message': conv.user_message,
                        'bot_response': conv.bot_response,
                        'intent': conv.intent,
                        'target_product': conv.target_product,
                        'confidence': conv.confidence,
                        'processing_time': conv.processing_time,
                        'sources_count': random.randint(1, 5),
                        'user_ip': conv.user_ip,
                        'created_at': conv.created_at
                    })
                
                cursor.executemany(insert_query, batch_data)
                conn.commit()
                print(f"  ‚Ä¢ Inserted batch {i//batch_size + 1}: {len(batch)} conversations")
            
            print(f"üí¨ Total conversations inserted: {len(conversations)}")
            
        finally:
            cursor.close()
            conn.close()
    
    async def seed_cache_data(self):
        """Seed Redis v·ªõi sample cache data"""
        print("\nüóÑÔ∏è Seeding cache data...")
        
        # Generate sample cache entries
        cache_entries = [
            {
                'key': 'chat:hash_abc123',
                'response': {
                    'response': 'S·∫£n ph·∫©m A c√≥ t√≠nh nƒÉng b·∫£o m·∫≠t SSL/TLS encryption, two-factor authentication v√† access control.',
                    'confidence': 0.95,
                    'intent': 'product_inquiry',
                    'sources': ['product_a_features_1', 'product_a_features_3']
                },
                'ttl': 3600
            },
            {
                'key': 'chat:hash_def456', 
                'response': {
                    'response': 'Gi√° c·∫£ s·∫£n ph·∫©m A b·∫Øt ƒë·∫ßu t·ª´ 99,000 VNƒê/th√°ng cho g√≥i Basic.',
                    'confidence': 0.92,
                    'intent': 'pricing_inquiry',
                    'sources': ['product_a_pricing_1']
                },
                'ttl': 3600
            }
        ]
        
        for entry in cache_entries:
            self.redis_client.setex(
                entry['key'],
                entry['ttl'], 
                json.dumps(entry['response'])
            )
        
        # Add real-time metrics
        today = datetime.now().strftime('%Y-%m-%d')
        self.redis_client.setex(f"conversations:daily:{today}", 86400, "150")
        self.redis_client.setex(f"intents:daily:{today}:product_inquiry", 86400, "65")
        self.redis_client.setex(f"intents:daily:{today}:pricing_inquiry", 86400, "42")
        
        print(f"üóÑÔ∏è Cache entries created: {len(cache_entries)}")
    
    def generate_fake_conversations(self, count: int) -> List[FakeConversation]:
        """Generate fake conversations data"""
        conversations = []
        
        # Sample user queries v√† responses
        queries_responses = [
            # Product inquiries
            ("S·∫£n ph·∫©m A c√≥ nh·ªØng t√≠nh nƒÉng g√¨?", "S·∫£n ph·∫©m A c√≥ c√°c t√≠nh nƒÉng ch√≠nh nh∆∞ b·∫£o m·∫≠t SSL, API integration, real-time analytics v√† scalable architecture.", "product_inquiry", "product_a"),
            ("Product B ho·∫°t ƒë·ªông nh∆∞ th·∫ø n√†o?", "Product B s·ª≠ d·ª•ng AI engine ƒë·ªÉ t·ª± ƒë·ªông h√≥a quy tr√¨nh, v·ªõi kh·∫£ nƒÉng machine learning v√† predictive analytics.", "product_inquiry", "product_b"),
            ("T√≠nh nƒÉng b·∫£o m·∫≠t c·ªßa s·∫£n ph·∫©m ra sao?", "H·ªá th·ªëng b·∫£o m·∫≠t bao g·ªìm encryption AES-256, two-factor authentication v√† security monitoring 24/7.", "product_inquiry", None),
            
            # Pricing inquiries  
            ("Gi√° c·∫£ s·∫£n ph·∫©m A bao nhi√™u?", "S·∫£n ph·∫©m A c√≥ 3 g√≥i: Basic (99k/th√°ng), Pro (299k/th√°ng), Enterprise (999k/th√°ng).", "pricing_inquiry", "product_a"),
            ("Chi ph√≠ s·ª≠ d·ª•ng th·∫ø n√†o?", "Chi ph√≠ ƒë∆∞·ª£c t√≠nh theo s·ªë user v√† t√≠nh nƒÉng s·ª≠ d·ª•ng, b·∫Øt ƒë·∫ßu t·ª´ 99,000 VNƒê/th√°ng.", "pricing_inquiry", None),
            ("C√≥ khuy·∫øn m√£i kh√¥ng?", "Hi·ªán t·∫°i c√≥ ∆∞u ƒë√£i 20% cho kh√°ch h√†ng ƒëƒÉng k√Ω nƒÉm ƒë·∫ßu v√† mi·ªÖn ph√≠ trial 14 ng√†y.", "pricing_inquiry", None),
            
            # Support requests
            ("L√†m sao ƒë·ªÉ setup s·∫£n ph·∫©m?", "B·∫°n c√≥ th·ªÉ follow h∆∞·ªõng d·∫´n setup trong docs ho·∫∑c li√™n h·ªá support team ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£ chi ti·∫øt.", "support_request", None),
            ("T√¥i g·∫∑p l·ªói k·∫øt n·ªëi API", "Vui l√≤ng ki·ªÉm tra API key v√† endpoint URL. N·∫øu v·∫´n l·ªói, h√£y g·ª≠i error logs cho team support.", "support_request", None),
            
            # Warranty inquiries
            ("Ch√≠nh s√°ch b·∫£o h√†nh nh∆∞ th·∫ø n√†o?", "Ch√∫ng t√¥i c√≥ ch√≠nh s√°ch b·∫£o h√†nh 12 th√°ng v√† h·ªó tr·ª£ k·ªπ thu·∫≠t 24/7 cho t·∫•t c·∫£ s·∫£n ph·∫©m.", "warranty_inquiry", None),
            ("C√≥ th·ªÉ ho√†n ti·ªÅn kh√¥ng?", "C√≥ ch√≠nh s√°ch ho√†n ti·ªÅn 100% trong 30 ng√†y ƒë·∫ßu n·∫øu kh√¥ng h√†i l√≤ng v·ªõi d·ªãch v·ª•.", "warranty_inquiry", None),
            
            # Contact requests
            ("Th√¥ng tin li√™n h·ªá c√¥ng ty?", "C√¥ng ty ABC, ƒë·ªãa ch·ªâ: 123 Nguy·ªÖn Tr√£i, H√† N·ªôi. Hotline: 1900-xxxx, Email: support@company.com", "contact_request", None),
            ("L√†m sao li√™n h·ªá support?", "B·∫°n c√≥ th·ªÉ li√™n h·ªá qua hotline 1900-xxxx, email support@company.com ho·∫∑c chat tr·ª±c ti·∫øp tr√™n website.", "contact_request", None),
        ]
        
        # Generate conversations
        for i in range(count):
            query, response, intent, product = random.choice(queries_responses)
            
            # Add variations
            if random.random() < 0.3:  # 30% chance ƒë·ªÉ th√™m variations
                query = f"{query} {random.choice(['Xin ch√†o!', 'C·∫£m ∆°n b·∫°n.', 'Vui l√≤ng t∆∞ v·∫•n.'])}"
            
            conv = FakeConversation(
                session_id=f"session_{uuid.uuid4().hex[:12]}",
                user_message=query,
                bot_response=response,
                intent=intent,
                target_product=product,
                confidence=random.uniform(0.7, 0.98),
                processing_time=random.uniform(0.5, 3.5),
                user_ip=f"192.168.{random.randint(1,255)}.{random.randint(1,255)}",
                created_at=datetime.now() - timedelta(
                    days=random.randint(0, 30),
                    hours=random.randint(0, 23),
                    minutes=random.randint(0, 59)
                )
            )
            conversations.append(conv)
        
        return conversations
    
    def get_product_a_features_docs(self) -> List[Dict]:
        """Sample documents cho Product A features"""
        return [
            {
                'content': 'S·∫£n ph·∫©m A cung c·∫•p t√≠nh nƒÉng b·∫£o m·∫≠t SSL/TLS encryption ƒë·∫ßu cu·ªëi, ƒë·∫£m b·∫£o d·ªØ li·ªáu ƒë∆∞·ª£c m√£ h√≥a trong qu√° tr√¨nh truy·ªÅn t·∫£i. H·ªá th·ªëng h·ªó tr·ª£ ch·ª©ng ch·ªâ SSL wildcard v√† EV SSL cho ƒë·ªô tin c·∫≠y cao nh·∫•t.',
                'title': 'T√≠nh nƒÉng b·∫£o m·∫≠t SSL',
                'category': 'security',
                'product': 'product_a',
                'section': 'features'
            },
            {
                'content': 'API Integration c·ªßa s·∫£n ph·∫©m A h·ªó tr·ª£ RESTful API v√† GraphQL, cho ph√©p t√≠ch h·ª£p d·ªÖ d√†ng v·ªõi c√°c h·ªá th·ªëng third-party. C√≥ rate limiting, authentication token v√† comprehensive documentation.',
                'title': 'API Integration',
                'category': 'integration',
                'product': 'product_a', 
                'section': 'features'
            },
            {
                'content': 'Real-time Analytics dashboard cung c·∫•p insights v·ªÅ user behavior, performance metrics v√† business intelligence. H·ªó tr·ª£ custom reports, data export v√† real-time alerts.',
                'title': 'Analytics Dashboard',
                'category': 'analytics',
                'product': 'product_a',
                'section': 'features'
            },
            {
                'content': 'Scalable Architecture ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ handle millions of requests per day v·ªõi auto-scaling capability. S·ª≠ d·ª•ng microservices pattern v√† container orchestration.',
                'title': 'Ki·∫øn tr√∫c m·ªü r·ªông',
                'category': 'architecture',
                'product': 'product_a',
                'section': 'features'
            },
            {
                'content': 'Two-Factor Authentication (2FA) b·∫£o v·ªá accounts v·ªõi multiple layers security. H·ªó tr·ª£ SMS, email v√† authenticator apps nh∆∞ Google Authenticator, Authy.',
                'title': 'X√°c th·ª±c 2 l·ªõp',
                'category': 'security',
                'product': 'product_a',
                'section': 'features'
            }
        ]
    
    def get_product_a_pricing_docs(self) -> List[Dict]:
        """Sample documents cho Product A pricing"""
        return [
            {
                'content': 'G√≥i Basic - 99,000 VNƒê/th√°ng: Ph√π h·ª£p cho startup v√† small business. Bao g·ªìm: 1,000 API calls/day, 5GB storage, email support, basic analytics. Kh√¥ng gi·ªõi h·∫°n s·ªë users.',
                'title': 'G√≥i Basic',
                'category': 'pricing',
                'product': 'product_a',
                'section': 'plans'
            },
            {
                'content': 'G√≥i Pro - 299,000 VNƒê/th√°ng: D√†nh cho medium business. Bao g·ªìm: 10,000 API calls/day, 50GB storage, priority support, advanced analytics, custom integrations, SLA 99.9%.',
                'title': 'G√≥i Pro', 
                'category': 'pricing',
                'product': 'product_a',
                'section': 'plans'
            },
            {
                'content': 'G√≥i Enterprise - 999,000 VNƒê/th√°ng: Gi·∫£i ph√°p cho large enterprise. Unlimited API calls, 500GB storage, 24/7 dedicated support, white-label option, custom development, SLA 99.99%.',
                'title': 'G√≥i Enterprise',
                'category': 'pricing', 
                'product': 'product_a',
                'section': 'plans'
            },
            {
                'content': 'Khuy·∫øn m√£i ƒë·∫∑c bi·ªát: Gi·∫£m 20% cho kh√°ch h√†ng ƒëƒÉng k√Ω tr·∫£ tr∆∞·ªõc 12 th√°ng. Mi·ªÖn ph√≠ trial 14 ng√†y cho t·∫•t c·∫£ g√≥i. Kh√¥ng ph√≠ setup v√† migration t·ª´ competitors.',
                'title': '∆Øu ƒë√£i v√† khuy·∫øn m√£i',
                'category': 'promotion',
                'product': 'product_a', 
                'section': 'pricing'
            }
        ]
    
    def get_product_b_features_docs(self) -> List[Dict]:
        """Sample documents cho Product B features"""
        return [
            {
                'content': 'Product B s·ª≠ d·ª•ng AI Engine ti√™n ti·∫øn v·ªõi Machine Learning algorithms ƒë·ªÉ t·ª± ƒë·ªông h√≥a business processes. H·ªó tr·ª£ neural networks, deep learning v√† natural language processing.',
                'title': 'AI Engine',
                'category': 'ai',
                'product': 'product_b',
                'section': 'features'
            },
            {
                'content': 'Predictive Analytics c·ªßa Product B ph√¢n t√≠ch historical data ƒë·ªÉ d·ª± ƒëo√°n trends v√† behaviors. Accuracy rate > 95% v·ªõi real-time predictions v√† actionable insights.',
                'title': 'Predictive Analytics',
                'category': 'analytics',
                'product': 'product_b',
                'section': 'features'
            },
            {
                'content': 'Workflow Automation cho ph√©p t·∫°o custom workflows without coding. Drag-and-drop interface, conditional logic, integrations v·ªõi 200+ third-party services.',
                'title': 'T·ª± ƒë·ªông h√≥a quy tr√¨nh',
                'category': 'automation',
                'product': 'product_b',
                'section': 'features'
            }
        ]
    
    def get_warranty_support_docs(self) -> List[Dict]:
        """Sample documents cho warranty & support"""
        return [
            {
                'content': 'Ch√≠nh s√°ch b·∫£o h√†nh 12 th√°ng cho t·∫•t c·∫£ s·∫£n ph·∫©m v√† d·ªãch v·ª•. B·∫£o h√†nh cover t·∫•t c·∫£ technical issues, bugs v√† performance problems. Th·ªùi gian response < 24 hours.',
                'title': 'Ch√≠nh s√°ch b·∫£o h√†nh',
                'category': 'warranty',
                'section': 'support'
            },
            {
                'content': 'H·ªó tr·ª£ k·ªπ thu·∫≠t 24/7 qua multiple channels: hotline, email, live chat v√† video call. Dedicated support team v·ªõi experience > 5 years trong industry.',
                'title': 'H·ªó tr·ª£ k·ªπ thu·∫≠t',
                'category': 'support',
                'section': 'support' 
            },
            {
                'content': 'Ch√≠nh s√°ch ho√†n ti·ªÅn 100% trong 30 ng√†y ƒë·∫ßu n·∫øu kh√¥ng h√†i l√≤ng. Kh√¥ng c·∫ßn l√Ω do, process ho√†n ti·ªÅn trong 3-5 business days. √Åp d·ª•ng cho t·∫•t c·∫£ g√≥i d·ªãch v·ª•.',
                'title': 'Ho√†n ti·ªÅn',
                'category': 'refund',
                'section': 'policy'
            }
        ]
    
    def get_contact_company_docs(self) -> List[Dict]:
        """Sample documents cho company contact"""
        return [
            {
                'content': 'C√¥ng ty ABC Technology - Chuy√™n cung c·∫•p gi·∫£i ph√°p c√¥ng ngh·ªá cho doanh nghi·ªáp. ƒê·ªãa ch·ªâ: T·∫ßng 10, T√≤a nh√† XYZ, 123 Nguy·ªÖn Tr√£i, Thanh Xu√¢n, H√† N·ªôi. Website: www.company.com',
                'title': 'Th√¥ng tin c√¥ng ty',
                'category': 'company',
                'section': 'contact'
            },
            {
                'content': 'Th√¥ng tin li√™n h·ªá: Hotline: 1900-1234 (24/7), Email: support@company.com, sales@company.com. Social media: Facebook/CompanyABC, LinkedIn/company-abc-tech',
                'title': 'Li√™n h·ªá',
                'category': 'contact',
                'section': 'contact'
            },
            {
                'content': 'ƒê·ªôi ng≈© 50+ engineers v√† developers v·ªõi kinh nghi·ªám 10+ nƒÉm. ƒê√£ ph·ª•c v·ª• 500+ kh√°ch h√†ng t·ª´ startup ƒë·∫øn enterprise. Established 2015, ISO 27001 certified.',
                'title': 'V·ªÅ ch√∫ng t√¥i',
                'category': 'about',
                'section': 'company'
            }
        ]
    
    async def verify_data(self):
        """Verify d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c seed correctly"""
        print("\nüîç Verifying seeded data...")
        
        # Check FAISS collections
        faiss_status = await self.faiss_manager.health_check()
        print(f"  ‚Ä¢ FAISS Collections: {faiss_status['collections']}")
        
        # Check database
        conn = psycopg2.connect(self.db_url)
        cursor = conn.cursor()
        
        cursor.execute("SELECT COUNT(*) FROM conversations")
        conv_count = cursor.fetchone()[0]
        print(f"  ‚Ä¢ Database conversations: {conv_count}")
        
        cursor.execute("SELECT intent, COUNT(*) FROM conversations GROUP BY intent")
        intent_stats = cursor.fetchall()
        print(f"  ‚Ä¢ Intent distribution: {dict(intent_stats)}")
        
        cursor.close()
        conn.close()
        
        # Check Redis
        cache_keys = self.redis_client.keys("chat:*")
        print(f"  ‚Ä¢ Redis cache entries: {len(cache_keys)}")
        
        print("‚úÖ Data verification completed!")

async def main():
    """Main function"""
    print("üå± Enterprise Chatbot Data Seeder")
    print("=" * 50)
    
    try:
        seeder = DataSeeder()
        await seeder.seed_all_data()
        
        print("\nüéâ Data seeding completed successfully!")
        print("\nüìä Data Summary:")
        print("  ‚Ä¢ FAISS: 5 collections v·ªõi sample documents")
        print("  ‚Ä¢ Database: 500 fake conversations")
        print("  ‚Ä¢ Redis: Cache entries v√† real-time metrics")
        print("\nüöÄ B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu test API endpoints!")
        
    except Exception as e:
        print(f"\n‚ùå Seeding failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main())
```

## Script ch·∫°y seeder

```bash
#!/bin/bash
# run_seeder.sh

echo "üå± Starting data seeding process..."

# Check if virtual environment exists
if [ ! -d "venv" ]; then
    echo "üì¶ Creating virtual environment..."
    python -m venv venv
fi

# Activate virtual environment
source venv/bin/activate  # Linux/Mac
# venv\Scripts\activate  # Windows

# Install dependencies if needed
pip install -r requirements.txt

# Run seeder
echo "üöÄ Running data seeder..."
python data_seeder.py

echo "‚úÖ Data seeding completed!"
```

## Test script ƒë·ªÉ verify data

```python
# test_seeded_data.py
"""
Test script ƒë·ªÉ verify seeded data ho·∫°t ƒë·ªông correctly
"""

import asyncio
import os
import requests
import json
from dotenv import load_dotenv

load_dotenv()

BASE_URL = f"http://localhost:{os.getenv('PORT', 8000)}"

async def test_api_endpoints():
    """Test c√°c API endpoints v·ªõi seeded data"""
    
    print("üß™ Testing API endpoints v·ªõi seeded data...")
    
    # Test cases
    test_queries = [
        {
            "message": "S·∫£n ph·∫©m A c√≥ t√≠nh nƒÉng b·∫£o m·∫≠t g√¨?",
            "context": {
                "url": "http://localhost:3000/product-a/features",
                "title": "Product A Features",
                "product": "product_a",
                "section": "features"
            },
            "expected_intent": "product_inquiry"
        },
        {
            "message": "Gi√° c·∫£ s·∫£n ph·∫©m A bao nhi√™u?", 
            "context": {
                "url": "http://localhost:3000/product-a/pricing",
                "title": "Product A Pricing",
                "product": "product_a",
                "section": "pricing"
            },
            "expected_intent": "pricing_inquiry"
        },
        {
            "message": "Th√¥ng tin li√™n h·ªá c√¥ng ty?",
            "context": {
                "url": "http://localhost:3000/contact",
                "title": "Contact Us",
                "section": "contact"
            },
            "expected_intent": "contact_request"
        }
    ]
    
    for i, test in enumerate(test_queries):
        print(f"\nüìù Test {i+1}: {test['message'][:30]}...")
        
        payload = {
            "message": test["message"],
            "session_id": f"test_session_{i+1}",
            "context": test["context"],
            "history": []
        }
        
        try:
            response = requests.post(
                f"{BASE_URL}/api/chat",
                json=payload,
                timeout=30
            )
            
            if response.status_code == 200:
                data = response.json()
                print(f"  ‚úÖ Response: {data['response'][:100]}...")
                print(f"  üìä Intent: {data.get('intent')} (expected: {test['expected_intent']})")
                print(f"  üéØ Confidence: {data.get('confidence', 0):.2f}")
                print(f"  ‚è±Ô∏è Processing time: {data.get('processing_time', 0):.2f}s")
                print(f"  üìö Sources: {len(data.get('sources', []))}")
            else:
                print(f"  ‚ùå Error {response.status_code}: {response.text}")
                
        except Exception as e:
            print(f"  ‚ùå Request failed: {e}")
    
    # Test health endpoint
    print(f"\nüè• Testing health endpoint...")
    try:
        response = requests.get(f"{BASE_URL}/api/health")
        if response.status_code == 200:
            health = response.json()
            print(f"  ‚úÖ System status: {health['status']}")
            print(f"  üìä Components: {list(health['components'].keys())}")
        else:
            print(f"  ‚ùå Health check failed: {response.status_code}")
    except Exception as e:
        print(f"  ‚ùå Health check error: {e}")

if __name__ == "__main__":
    asyncio.run(test_api_endpoints())
```

## C√°ch s·ª≠ d·ª•ng:

1. **Ch·∫°y seeder**:
```bash
# ƒê·∫£m b·∫£o database v√† Redis ƒë√£ ch·∫°y
docker-compose up -d postgres redis

# Ch·∫°y seeder
python data_seeder.py
```

2. **Start API server**:
```bash
python -m uvicorn main:app --host 0.0.0.0 --port 8000 --reload
```

3. **Test v·ªõi d·ªØ li·ªáu gi·∫£**:
```bash
python test_seeded_data.py
```

Script n√†y s·∫Ω t·∫°o:
- **FAISS Collections**: 5 collections v·ªõi ~20 documents realistic v·ªÅ products, pricing, support
- **Database**: 500 conversations v·ªõi distribution th·ª±c t·∫ø c·ªßa intents
- **Redis Cache**: Sample cache entries v√† metrics

D·ªØ li·ªáu ƒë∆∞·ª£c t·∫°o s·∫Ω c√≥ patterns gi·ªëng real usage ƒë·ªÉ test comprehensive c√°c t√≠nh nƒÉng c·ªßa chatbot system.